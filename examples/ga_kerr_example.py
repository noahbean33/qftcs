# -*- coding: utf-8 -*-
"""gakerr_v2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oe_VKfGnsxv54rqTvxlsU5iAXtwMBQGu

# GAKerr: Visualizing Kerr Black Holes with Geometric Algebra

This notebook combines `EinsteinPy` for global Kerr spacetime structure and `clifford` (Geometric Algebra) for local Lorentz frame visualizations. The goal is to show the physical effect of **frame-dragging** not as an integrated trajectory, but as the infinitesimal 'swirl' of a local observer's reference frame.
"""

# === Imports ===
import numpy as np
import matplotlib.pyplot as plt
import astropy.units as u
from aqft_curved.vendor.einsteinpy.coordinates import BoyerLindquistDifferential
from aqft_curved.vendor.einsteinpy.metric import Kerr
from aqft_curved.clifford import Cl, pretty
from numpy.linalg import cholesky

pretty(precision=2)

# === Setup Spacetime Algebra ===
# Spacetime Algebra G(1,3)
# We use firstIdx=0 to get 0-indexed basis vectors (e0, e1, e2, e3)
layout, blades = Cl(1, 3, names='e', firstIdx=0)
e0, e1, e2, e3 = blades['e0'], blades['e1'], blades['e2'], blades['e3']

"""## 1. Global Spacetime: Define Kerr Black Hole with EinsteinPy
First, we set up the background spacetime. We'll define a Kerr black hole with a high spin parameter to make the frame-dragging effects prominent.
"""

# Use a high-spin black hole to clearly see the effects
M = 4e30 * u.kg
a = 0.99 * u.one # Near-extremal spin

# Dummy coordinates for metric initialization
bl_dummy = BoyerLindquistDifferential(
    t=0.*u.s, r=1e3*u.m, theta=np.pi/2*u.rad, phi=0.*u.rad,
    v_r=0.*u.m/u.s, v_th=0.*u.rad/u.s, v_p=0.*u.rad/u.s
)

kerr_metric = Kerr(coords=bl_dummy, M=M, a=a)

# Get the singularity surfaces for plotting
singularities = kerr_metric.singularities()
print("Singularities:", singularities)

# Prepare singularity surfaces for plotting
theta = np.linspace(0, 2 * np.pi, 200)

def polar_to_cartesian(r, theta_vals):
    # Helper to convert radial plot points to cartesian
    if isinstance(r, u.Quantity):
        r_val = r.value
    else:
        r_val = r
    return r_val * np.sin(theta_vals), r_val * np.cos(theta_vals)

# Ergosphere
Eo = singularities['outer_ergosphere'](theta)
Xeo, Yeo = polar_to_cartesian(Eo, theta)

# Outer Horizon
Ho = singularities['outer_horizon']
Xho, Yho = polar_to_cartesian(Ho, theta)

"""## 2. The Bridge: From Global Metric to Local Physics
This is the core of the project. We define functions to bridge `EinsteinPy` and `clifford`.
1. `get_local_tetrad`: At any point in spacetime, the coordinate basis (`dt, dr, dθ, dφ`) is not orthonormal. A physical observer experiences a flat, Minkowskian reality locally. This function calculates the basis vectors (`e_t, e_r, e_θ, e_φ`) of that local flat frame, called a tetrad or vierbein.
2. `get_frame_dragging_rotor`: This function calculates the physical rate of frame dragging (`Ω`) and constructs the Geometric Algebra `rotor` that performs this transformation.
"""

def get_local_tetrad(kerr, r_coord, theta_coord):
    """
    Constructs an orthonormal tetrad using the Gram-Schmidt process.
    This is necessary because the spacetime metric is not positive-definite.
    """
    bl = BoyerLindquistDifferential(t=0*u.s, r=r_coord*u.m, theta=theta_coord*u.rad, phi=0*u.rad, v_r=0.*u.m/u.s, v_th=0.*u.rad/u.s, v_p=0.*u.rad/u.s)
    g = kerr.metric_covariant(bl)

    # Define a dot product with respect to the metric g
    def g_dot(v1, v2):
        return np.dot(v1, np.dot(g, v2))

    # Start with standard basis vectors (as numpy arrays)
    coord_basis = [np.array([1.,0.,0.,0.]), np.array([0.,1.,0.,0.]), np.array([0.,0.,1.,0.]), np.array([0.,0.,0.,1.])]
    
    # Gram-Schmidt
    ortho_vecs = [np.zeros(4) for _ in range(4)]
    ortho_vecs[0] = coord_basis[0]
    for i in range(1, 4):
        ortho_vecs[i] = coord_basis[i]
        for j in range(i):
            # projection of coord_basis[i] onto ortho_vecs[j]
            dot_val = g_dot(ortho_vecs[j], ortho_vecs[j])
            if abs(dot_val) < 1e-15: # Avoid division by zero for null vectors
                continue
            proj = g_dot(ortho_vecs[j], coord_basis[i]) / dot_val
            ortho_vecs[i] -= proj * ortho_vecs[j]

    # Normalize and form the transformation matrix (columns are the new basis vectors)
    try:
        e_mat = np.array([v / np.sqrt(abs(g_dot(v, v))) for v in ortho_vecs]).T
    except (ZeroDivisionError, ValueError):
        return None # Failed to construct tetrad
    
    # The columns of e_mat are the tetrad vectors expressed in the coordinate basis.
    # We convert them to multivectors.
    basis_mvs = [e0, e1, e2, e3]
    tetrad_vectors = {}
    tetrad_names = ['t', 'r', 'theta', 'phi']
    for i, name in enumerate(tetrad_names):
        components = e_mat[:, i]
        tetrad_vectors[name] = sum(components[j] * basis_mvs[j] for j in range(4))

    return tetrad_vectors

def get_frame_dragging_rotor(kerr, r_coord, theta_coord, dt=1.0):
    """
    Calculates the frame-dragging angular velocity and constructs the corresponding rotor.
    """
    # Get metric components
    bl = BoyerLindquistDifferential(t=0*u.s, r=r_coord*u.m, theta=theta_coord*u.rad, phi=0*u.rad, v_r=0.*u.m/u.s, v_th=0.*u.rad/u.s, v_p=0.*u.rad/u.s)
    g = kerr.metric_covariant(bl)
    g_tphi = g[0, 3]
    g_phiphi = g[3, 3]

    # Frame-dragging angular velocity Omega = -g_tphi / g_phiphi
    omega = -g_tphi / g_phiphi

    # The local tetrad frame
    tetrad = get_local_tetrad(kerr, r_coord, theta_coord)
    if tetrad is None:
        return None

    # The frame dragging is a rotation in the local time-phi plane.
    # The generator of this rotation is the bivector for that plane.
    B = tetrad['t'] ^ tetrad['phi']
    B_normalized = B / abs(B)

    # Create the rotor for a rotation by angle theta in the plane B is R = cos(theta/2) + B_normalized*sin(theta/2)
    # Here the total angle is omega * dt.
    angle = omega * dt / 2.0
    R = np.cos(angle) + B_normalized * np.sin(angle)
    return R

"""## 3. Simulation: Visualize the Local Frame Dragging
Now we'll place observers at various points outside the black hole and see how their local reference frames are twisted by frame-dragging. We'll visualize the local 'radial' direction vector and how it gets dragged in the direction of rotation.
"""

# === Visualization Code ===

# Set up the plot
fig, ax = plt.subplots(1, 1, figsize=(12, 12))
ax.set_facecolor('black')

# Plot Ergosphere (red) and Horizon (grey)
# The variables Xeo, Yeo, Xho, Yho are assumed to be defined from the EinsteinPy section
ax.fill(Xeo, Yeo, color='#8B0000', alpha=0.6, label='Ergosphere', zorder=1)
ax.fill(Xho, Yho, color='#404040', alpha=1.0, label='Event Horizon', zorder=2)
ax.plot([0], [0], 'o', color='white', markersize=6, zorder=10) # Singularity

# Define points to sample the frame dragging effect
# We use the value of Ho (outer horizon radius) from the EinsteinPy calculations
radii_to_plot = np.linspace(Ho * 1.1, Ho * 3.0, 7)
angles_to_plot = np.linspace(0, 2 * np.pi, 16)[:-1]

# --- PLOTTING FIX 1: QUIVER SCALE ---
# This value determines the arrow size. A smaller number makes the arrows LARGER.
# This fixes the "invisible arrow" bug.
quiver_scale = 30.0

# Increase the visualization timestep to make the dragging effect obvious
dt_vis = 1.5

for r_val in radii_to_plot:
    for theta_val in angles_to_plot:
        # Convert polar coordinates to cartesian for placing the arrows
        x_pos = r_val * np.cos(theta_val)
        y_pos = r_val * np.sin(theta_val)

        # We are visualizing on the equatorial plane (theta=pi/2) for simplicity
        eval_theta_plane = np.pi / 2

        # Get the local frame and the frame-dragging rotor
        tetrad = get_local_tetrad(kerr_metric, r_val, eval_theta_plane)
        if tetrad is None:
            continue
        R = get_frame_dragging_rotor(kerr_metric, r_val, eval_theta_plane, dt=dt_vis)
        if R is None:
            continue

        # This is the "pure" radial direction vector in the observer's local frame
        local_radial_vec = tetrad['r']

        # Apply the rotor to see how the vector is dragged by spacetime
        dragged_radial_vec = (R * local_radial_vec * ~R).normal()

        # --- PLOTTING FIX 2: VECTOR ORIENTATION ---
        # The tetrad vectors are already expressed in the global (e1, e2) basis.
        # No extra rotation matrix is needed. This fixes the "grid pattern" bug.
        # We directly use the e1 (x) and e2 (y) components by getting their indices.
        d1 = layout.names.index('e1')
        d2 = layout.names.index('e2')
        uv_original = (local_radial_vec.value[d1], local_radial_vec.value[d2])
        uv_dragged = (dragged_radial_vec.value[d1], dragged_radial_vec.value[d2])

        # Plot the original (blue) and dragged (cyan) frame vectors
        ax.quiver(x_pos, y_pos, uv_original[0], uv_original[1], color='deepskyblue', scale=quiver_scale, width=0.004, headwidth=5, zorder=5)
        ax.quiver(x_pos, y_pos, uv_dragged[0], uv_dragged[1], color='cyan', scale=quiver_scale, width=0.004, headwidth=5, zorder=5)


# --- Final Plot Setup ---
from matplotlib.lines import Line2D
legend_elements = [
    Line2D([0], [0], color='#8B0000', alpha=0.6, lw=4, label='Ergosphere'),
    Line2D([0], [0], color='#404040', lw=4, label='Event Horizon'),
    Line2D([], [], color='deepskyblue', marker='>', linestyle='None', markersize=10, label='Local Radial Vector'),
    Line2D([], [], color='cyan', marker='>', linestyle='None', markersize=10, label='...after Frame Drag')
]
ax.legend(handles=legend_elements, loc='upper right', facecolor='black', edgecolor='white', labelcolor='white')
ax.set_title(f"Visualization of Local Frame-Dragging (a={a.value})", color='white', fontsize=16)
ax.set_xlabel("x (meters)", color='white')
ax.set_ylabel("y (meters)", color='white')
ax.tick_params(axis='x', colors='white')
ax.tick_params(axis='y', colors='white')
ax.set_aspect('equal')
ax.grid(True, linestyle=':', color='white', alpha=0.3)

plt.tight_layout()
plt.show()